from random import random
from queue import PriorityQueue
from Chessboard import Node
from Chessboard import h_value, number_of_attacks
import time


def print_board(state, n):
	for row in range(0, n):

		for col in range(0, n):
			# O = empty, Y = queen
			if(state[col] == str(row + 1)):
				print('7', end = ' ')
			else:
				print('O', end = ' ')


# helper function to number_of_attacks
# only count from the given column on (do not consider the queens that attack from
# a lower col or row)
# col and int is an integer from (0, n], so it is the position starting with 1
# returns the number of attacks on the given queen

def randomly_generate_state(n):
	is_used = [False] * n

	state = ' '

	for col in range(0, n):
		rand_number = int(n * random()) + 1
		
		if col != n - 1:			
			is_used[rand_number - 1] = True
			state = state[:col] + str(rand_number) + state[col+1:]
		# place the last remaining digit that has not been generated by the random function
		else:
			for j in range(0, n):
				if is_used[j] == False:
					state = state[:col] + str(j + 1) + state[col+1:]

					break

	return state	

def steepest_ascent_hill_climbing(state, n):
	start_time = time.time()
	elapsed_time = 0

	best_next_nodes = PriorityQueue()

	original_state = state
	original_h_value = h_value(original_state, n)
	
	current_h_value = h_value(original_state, n)


	lowest_h_value = original_h_value + 1

	search_cost = 0

	
	col_of_queen_to_move = 0
	row_to_move = 0
	next_state = original_state

	move_found = True

	while move_found == True and lowest_h_value != 0:
		# reset the priority queue for the next iteration
		#best_next_nodes = PriorityQueue()
		current_h_value = original_h_value
		move_found = False
		for col in range(0, n):
		
			current_location = int(state[col]) - 1
			#print(original_state)
			# check the h_value for each possible move of each queen
			for row in range(0, n):
				if current_location == row:
					continue
				else:
					# replace the row of the queen at col with the row of the loop
					state = state[:col] + str(row+1) + state[col+1:]

					current_h_value = h_value(state, n)

					if current_h_value < lowest_h_value:
						move_found = True

						search_cost += 1
						
						lowest_h_value = current_h_value
						col_of_queen_to_move = col
						row_to_move = row
						next_state = state
						

					state = original_state


		if move_found == True:

			original_state = next_state
			original_h_value = lowest_h_value

	# if the h_value = 0, then solution was found, so return true
	elapsed_time = (time.time() - start_time) * 1000

	if lowest_h_value == 0:
		print('elapsed_time = ' + str(round(elapsed_time,2)))
		print('search_cost = ' + str(search_cost) + ' moves')
		solution = [round(elapsed_time, 2), search_cost, Node(original_state, n)]
		return solution


# evaluation function, higher the better
# number of non-attacking pairs of queens
# returns the number of non-attacking pairs
def fitness_function(state, n):
	# use the number_of_attacks to find the # of non-attacking pairs

	non_attacking_pairs = 0
	attacking_pairs = 0
	queens_being_tested = 0

	temp = 0

	for col in range(1, n + 1):
		queens_being_tested = n - col
		attacking_pairs = number_of_attacks(col, state, n)
		temp = queens_being_tested - attacking_pairs
		non_attacking_pairs += queens_being_tested - attacking_pairs 
	return non_attacking_pairs


# returns the best node found in the population. If more than one node has the same fitness,
# then randomly select one of them, and return
# @input:
#  	population: the k nodes from which we select the fittest node
# 	n: the dimensions of the chessboard
# @output:
#   node with a best fitness value
#   Already selected = avoid selecting it. remove it from the population not to select it again
#      it is a string that represents the state. 
def random_selection(population, n, already_selected = None):
	# remove the already_selected individual from the population to avoid selecting it again
	# first, check if it is not 0. If it is, then it is being called the first time (for x 
	# in the getetic_algorithm). 
	if already_selected is not None:
		population.remove(already_selected)


	# NOTE: list_of_fittest stores the individuals from the population, that are fitter than
	#    a predefined threshold. If we only stored the individuals that were fitter than the rest,
	#    we would have less options to choose from. More importantly, there are cases, where 
	#    there is an individual with an exceptionally high fitness value (e.g. 25), that no one 
	#    else has. This will eliminate everyone else from consideration, and will resemble the 
	#    steepest ascent hill climbing. With a threshold, we allow some variation for the 
	#    selected individuals. Also, in the lecture notes, we select 
	#    an individual that has a percent fitness of > 20, which is not necessarily the best, 
	#    but one of the best
	list_of_fittest = []


	# for calculating the fitness percentage for each individual
	total_fitness = 0

	# NOTE: the fitness threshold is (1/k)*100. k = population size
	#    So if it is better than the average, then it's fit
	#    e.g. if the population is 2, the threshold will be 50%
	fitness_threshold =  (1/len(population))*100


	# Calculate the fitness value of each individual in the population
	#   meanwhile, sum up the fitness values of all individaul, to get the total_fitness_value,
	#   which will later be used to get the fitness_value_percent of the individuals

	list_of_fittest = get_list_of_fittest(population, n)

	# randomly select an individual from the fittest
	rand_selection = int((len(list_of_fittest))*random())

	node_to_return = list_of_fittest[rand_selection]

	if already_selected is not None:
		population.append(already_selected)
	return node_to_return

# this function is a miniature version of the random_selection. This function only returns 
#  	the list of the fittest individuals, without randomly selecting any of them
def get_list_of_fittest(population, n):
	total_fitness = 0
	fitness_threshold =  (1/len(population))*100
	list_of_fittest = []

	for i in range(0, len(population)):
		state = population[i].get_current_state()
		current_fitness_value = fitness_function(state, n)

		total_fitness += current_fitness_value

		population[i].fitness_value = current_fitness_value

	average_fittest = total_fitness / len(population)

	for j in range(0, len(population)):
		population[j].fitness_value_percent = (population[j].fitness_value / total_fitness) * 100
		state = population[j].get_current_state()

		# if population[j].fitness_value_percent >= fitness_threshold:
		#	list_of_fittest.append(Node(state, n))

		if population[j].fitness_value >= average_fittest:
			list_of_fittest.append(Node(state, n))


	return list_of_fittest


def reproduce(x, y, n):
	# The crossover_point is randomly generated at each call to the function reproduce()
	crossover_point = int((n*random()))

	state_x = x.get_current_state()
	state_y = y.get_current_state()
	state_child = ''

	portion_of_x = state_x[:crossover_point]
	portion_of_y = state_y[crossover_point:]

	state_child = portion_of_x + portion_of_y

	
	child_node = Node(state_child, n)
	return child_node




def mutate(child_node, n):
	mutation_point = int(n * random())
	current_row = child_node.get_current_state()[mutation_point]

	# generating a random row number, which will replace the row of the queen 
	# 	at the mutation point
	randomly_generated_row = str(int((n) * random()) + 1)

	while randomly_generated_row == current_row:
		randomly_generated_row = str(int((n) * random()) + 1)		
		
	original_state = child_node.get_current_state()

	mutated_state = original_state[:mutation_point] + str(randomly_generated_row) + original_state[mutation_point+1:]

	child_node = Node(mutated_state, n)

	return child_node


# input
# n - the size of the chessboard (8)
# k - the population size (10)
# seconds_allowed = 2.22 
def genetic_algorithm(n, k, seconds = 2.22):
	# randomly generate k states (population), represented as a string
	start_time = time.time()
	#seconds = 2.22
	allowed_time = seconds * 1000 	# in miliseconds 
	elapsed_time_so_far = 0

	node = Node('11111111', n)

	# NOTE: search_cost = number of individuals in the population
	search_cost = 0

	# most_non_attacking_pairs is the number of non-attacking queens for the solution state.
	# 	for 8x8 board, this number is 7+6+5+4+3+2+1 = 28
	most_non_attacking_pairs = 0

	for i in range(0, n):
		most_non_attacking_pairs += i


	perfect_individual = Node('11111111', n) 

	# initialize the population list with default values, later to be replaced by randomly 
	# generated values
	population = [node] * k
	new_population = []



	for i in range(0, k):
		state = randomly_generate_state(n)

		node = Node(state, n)

		population[i] = node

	
	is_any_individual_fit_enough = False

	# if the list of fittest individuals has no individual or only one, then there is nothing the 
	#  	algorithm can do
	list_of_fittest = get_list_of_fittest(population, n)
	while elapsed_time_so_far < allowed_time and is_any_individual_fit_enough == False and len(list_of_fittest) > 1:
		list_of_fittest = get_list_of_fittest(population, n)

		for individual in range(0, len(population)):
			search_cost += 1

			x = random_selection(population, n)

			y = random_selection(population, n, x)


			child_node = reproduce(x, y, n)


			small_random_probability = int(100*random())

			if small_random_probability <= 50:
			 	#print('mutating child')
			 	child_node = mutate(child_node, n)


			new_population.append(child_node)



			if fitness_function(child_node.get_current_state(), n) == most_non_attacking_pairs:
				print('********************************************')
				print('Solution found')
				elapsed_time_so_far = (time.time() - start_time) * 1000

				is_any_individual_fit_enough = True
				perfect_individual = child_node
				
				print('elapsed_time = ' + str(round(elapsed_time_so_far, 2)))
				print('search_cost = ' + str(round(search_cost, 2)) + ' individuals')
				return_array = [round(elapsed_time_so_far, 2), round(search_cost, 2), child_node]
				return return_array
				#return child_node

		# the fittest of the old population are kept
		#list_of_fittest = get_list_of_fittest(population, n)
		#print(len(list_of_fittest))
		#population = list_of_fittest
		

		#population = new_population
		
		# for new_child in new_population:
		# 	population.append(new_child)

		population = new_population

		new_population = []
	

		elapsed_time_so_far = (time.time() - start_time) * 1000  	# convert to miliseconds

	print('*******************************************')
	print('Solution Not Found')
